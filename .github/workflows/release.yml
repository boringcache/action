name: Release Action

on:
  push:
    tags: ["v*"]
  workflow_dispatch:
    inputs:
      tag:
        description: 'Release tag (e.g., v1.0.0)'
        required: true

permissions:
  contents: write

jobs:
  build-and-release:
    name: Build and Release Action
    runs-on: ubuntu-latest
    outputs:
      release_tag: ${{ steps.release_meta.outputs.release_tag }}
    
    steps:
      - name: Determine release tag
        id: release_meta
        run: |
          tag_input="${{ github.event.inputs.tag }}"
          ref="${GITHUB_REF:-}"

          if [ -n "$tag_input" ]; then
            tag="$tag_input"
          elif [ "${ref#refs/tags/}" != "$ref" ]; then
            tag="${ref#refs/tags/}"
          else
            echo "This workflow must be triggered from a tag or provided a tag input." >&2
            exit 1
          fi

          echo "Using release tag: $tag"
          echo "RELEASE_TAG=$tag" >> "$GITHUB_ENV"
          echo "release_tag=$tag" >> "$GITHUB_OUTPUT"

      - name: Checkout code
        uses: actions/checkout@v4
        with:
          ref: ${{ env.RELEASE_TAG }}
          fetch-depth: 0

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "20"
          cache: "npm"

      - name: Install dependencies
        run: npm ci

      - name: Build action
        run: npm run build

      - name: Test action
        run: npm test

      - name: Verify package version matches tag
        run: |
          tag="${RELEASE_TAG}"
          pkg_version=$(node -p "require('./package.json').version")
          expected="v${pkg_version}"
          if [ "$expected" != "$tag" ]; then
            echo "Tag $tag does not match package.json version $pkg_version (expected $expected)" >&2
            exit 1
          fi

      - name: Create package archive
        run: |
          # Create release package
          mkdir -p release-package
          
          # Copy action files
          cp -r dist/ release-package/
          cp action.yml release-package/
          cp README.md release-package/
          cp LICENSE release-package/
          cp package.json release-package/
          
          # Create version info
          echo "ACTION_VERSION=${RELEASE_TAG}" > release-package/VERSION
          
          # Create archive
          cd release-package
          tar -czf ../release-package.tar.gz .
          cd ..

      - name: Create GitHub Release
        uses: softprops/action-gh-release@v1
        with:
          tag_name: ${{ env.RELEASE_TAG }}
          name: "BoringCache Action ${{ env.RELEASE_TAG }}"
          body: |
            ## BoringCache Action ${{ env.RELEASE_TAG }}

            **A portable build cache for GitHub Actions.**  
            Cache once, reuse anywhere ‚Äî CI, deploy, or local dev.

            ### üöÄ Features
            - **3x faster** than actions/cache
            - **Drop-in replacement** - works with existing workflows
            - **Portable caches** - reuse in CI, deploy, or local dev
            - **Workspace format** for multi-cache scenarios
            - **Cross-platform** caching (Linux, macOS, Windows)
            - **Intelligent compression** (LZ4/ZSTD auto-selection)
            - **Automatic CLI installation** - no setup required

            ### üì¶ Quick Start

            **Workspace Format (Recommended):**
            ```yaml
            - uses: boringcache/action@${{ env.RELEASE_TAG }}
              with:
                workspace: my-org/my-project
                entries: "node_modules:node-deps,target:build-cache"
              env:
                BORINGCACHE_API_TOKEN: ${{ secrets.BORINGCACHE_API_TOKEN }}
            ```

            **actions/cache Compatible:**
            ```yaml
            - uses: boringcache/action@${{ env.RELEASE_TAG }}
              with:
                path: ~/.npm
                key: deps-${{ hashFiles('package-lock.json') }}
                restore-keys: deps-
              env:
                BORINGCACHE_API_TOKEN: ${{ secrets.BORINGCACHE_API_TOKEN }}
            ```

            ### üîß Migration from actions/cache
            Simply replace `actions/cache@v4` with `boringcache/action@${{ env.RELEASE_TAG }}` and add the environment variable.

            ### üìä Performance Comparison

            | Scenario | actions/cache | BoringCache | Improvement |
            |----------|---------------|-------------|-------------|
            | Node modules (500MB) | 45s | 15s | **3x faster** |
            | Rust target (1GB) | 90s | 28s | **3.2x faster** |
            | Docker layers (2GB) | 180s | 55s | **3.3x faster** |

            ### üåç Portable Caching Benefits
            - **Cache once, reuse anywhere** - CI, deploy, local dev
            - **Cross-platform portability** - same cache on different systems
            - **Unified cache management** across all environments
            - **Cost-effective** - avoid rebuilding the same artifacts everywhere

            **CLI**: Installed automatically using official installer (install.boringcache.com)
          draft: false
          prerelease: false
          files: ./release-package.tar.gz

  update-major-version:
    name: Update Major Version Tag
    runs-on: ubuntu-latest
    needs: build-and-release
    if: startsWith(needs.build-and-release.outputs.release_tag, 'v')
    permissions:
      contents: write
    env:
      RELEASE_TAG: ${{ needs.build-and-release.outputs.release_tag }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
        
      - name: Update major version tag
        run: |
          TAG="${RELEASE_TAG}"
          git fetch origin "refs/tags/$TAG":"refs/tags/$TAG"
          MAJOR_VERSION=$(echo "$TAG" | cut -d. -f1)
          
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"
          
          # Force update the major version tag
          git tag -fa "$MAJOR_VERSION" -m "Update $MAJOR_VERSION to $TAG" "$TAG"
          git push origin "$MAJOR_VERSION" --force
